from service.Service import *

class Expectiminimax:

    def __init__(self):
        """
        Initializes the Expectiminimax class.

        Attributes:
            minimax_tree (list): A list of dictionaries representing the Minimax tree at each depth.
            parent (dict): A mapping from child states to their parent states.
        """
        self.minimax_tree = []  # Stores the utility values of states at different depths
        self.parent = {}        # Tracks parent-child relationships for states

    def decision(self, state, k, column):
        """
        Starts the decision-making process to find the best move.

        Args:
            state (int): The current game state as an integer.
            k (int): The depth of the tree to explore.
            column (int): The opponent's chosen column.

        Returns:
            tuple: The best child state and its utility value.
        """
        self.minimax_tree = []  # Clear the Minimax tree for this decision
        for i in range(k):      # Initialize an empty dictionary for each depth
            self.minimax_tree.append({})

        return self.maximize(state, k, column)

    def maximize(self, state, k, opponent_chosen_column):
        """
        Maximizes the utility value for the current state.

        Args:
            state (int): The current game state as an integer.
            k (int): The depth of the tree to explore.
            opponent_chosen_column (int): The opponent's chosen column.

        Returns:
            tuple: The best child state and its maximum utility value.
        """
        if k <= 1:  # Base case: evaluate the utility of the state
            self.minimax_tree[k-1][int(state)] = eval(state)
            return None, self.minimax_tree[k-1][int(state)]

        max_child = None
        max_utility = -float("inf")  # Initialize maximum utility to negative infinity

        # Explore all child states generated by the "get_children_probability" function
        for child, prob, chosen_column in get_children_probability(state, "2", opponent_chosen_column):
            _, utility = self.minimize(child, k - 2, chosen_column)
            self.parent[child] = state  # Track the parent of this child state

            # Update the maximum utility if this child's utility is better
            if prob * utility > max_utility:
                max_utility = prob * utility
                max_child = child

        # Store the maximum utility in the Minimax tree
        self.minimax_tree[k-1][int(state)] = max_utility
        return max_child, max_utility

    def minimize(self, state, k, opponent_chosen_column):
        """
        Minimizes the utility value for the current state.

        Args:
            state (int): The current game state as an integer.
            k (int): The depth of the tree to explore.
            opponent_chosen_column (int): The opponent's chosen column.

        Returns:
            tuple: The best child state and its minimum utility value.
        """
        if k <= 1:  # Base case: evaluate the utility of the state
            self.minimax_tree[k-1][int(state)] = eval(state)
            return None, self.minimax_tree[k-1][int(state)]

        min_child = None
        min_utility = float("inf")  # Initialize minimum utility to positive infinity

        # Explore all child states generated by the "get_children_probability" function
        for child, prob, chosen_column in get_children_probability(state, "1", opponent_chosen_column):
            _, utility = self.maximize(child, k - 2, chosen_column)
            self.parent[child] = state  # Track the parent of this child state

            # Update the minimum utility if this child's utility is better
            if prob * utility < min_utility:
                min_utility = prob * utility
                min_child = child

        # Store the minimum utility in the Minimax tree
        self.minimax_tree[k-1][int(state)] = min_utility
        return min_child, min_utility

    def get_minimax_tree(self):
        """
        Retrieves the Minimax tree built during the decision-making process.

        Returns:
            list: A list of dictionaries representing the utility values of states at each depth.
        """
        self.minimax_tree.reverse()  # Reverse the tree to present it from root to leaf
        return self.minimax_tree

    def get_parent(self):
        """
        Retrieves the parent mapping built during the decision-making process.

        Returns:
            dict: A dictionary mapping child states to their parent states.
        """
        return self.parent
